# 可达工作空间采样实现方案

## 实现思路

### 方案1：预计算所有可达位置（推荐）

**步骤**：
1. 在初始化时，遍历所有可能的关节配置（采样方式）
2. 使用正向运动学计算每个手指的可达位置和姿态
3. 过滤掉碰撞的配置
4. 存储每个手指的可达位置和姿态
5. 修改采样函数，从预计算的可达位置中随机选择

**优点**：
- 采样速度快（只需随机选择）
- 保证所有采样位置都是可达的
- 避免运行时计算正向运动学

**缺点**：
- 需要内存存储可达位置
- 初始化时间较长

### 方案2：按需计算（备选）

**步骤**：
1. 采样时随机选择关节配置
2. 计算正向运动学
3. 检查是否可达（无碰撞）
4. 如果不可达，重新采样

**优点**：
- 不需要预计算
- 内存占用小

**缺点**：
- 采样可能较慢（需要多次重试）
- 当前已有类似实现

## 推荐实现：方案1（预计算）

### 1. 添加配置参数

在 `wuji_pos_force_config.py` 中添加：
```python
class goal_ee:
    # ... existing code ...
    
    # 可达工作空间采样参数
    precompute_reachable_workspace = True  # 是否预计算可达工作空间
    workspace_sampling_density = 10  # 每个关节的采样点数（例如10点，总共10^4=10000个配置）
    workspace_sampling_method = 'uniform'  # 'uniform' 或 'random'
```

### 2. 添加预计算函数

在 `wuji_robot_pos_force.py` 中添加：
```python
def _precompute_reachable_workspace(self):
    """
    预计算所有手指的可达工作空间
    
    为每个手指分别计算：
    - 可达位置列表 (reachable_positions)
    - 对应的姿态列表 (reachable_orientations)
    - 对应的关节配置列表 (reachable_joint_configs) - 可选，用于调试
    """
    print("开始预计算可达工作空间...")
    
    # 获取每个手指的关节索引
    # 假设每个手指有4个关节，需要根据实际URDF调整
    finger_joint_indices = self._get_finger_joint_indices()
    
    self.reachable_workspace = {}  # 存储每个手指的可达位置
    
    for finger_idx in range(len(self.finger_tips_idx)):
        print(f"计算手指 {finger_idx+1} 的可达工作空间...")
        
        # 获取该手指的关节索引
        joint_indices = finger_joint_indices[finger_idx]
        num_joints = len(joint_indices)
        
        # 获取关节限制
        low = self.dof_pos_limits[joint_indices, 0].cpu().numpy()
        high = self.dof_pos_limits[joint_indices, 1].cpu().numpy()
        
        # 生成关节配置采样
        if self.cfg.goal_ee.workspace_sampling_method == 'uniform':
            # 均匀采样
            samples_per_joint = self.cfg.goal_ee.workspace_sampling_density
            joint_samples = []
            for i in range(num_joints):
                joint_samples.append(np.linspace(low[i], high[i], samples_per_joint))
            
            # 生成所有组合（笛卡尔积）
            from itertools import product
            joint_configs = np.array(list(product(*joint_samples)))
        else:
            # 随机采样
            num_samples = self.cfg.goal_ee.workspace_sampling_density ** num_joints
            joint_configs = np.random.uniform(
                low, high, 
                size=(num_samples, num_joints)
            )
        
        # 计算正向运动学
        reachable_positions = []
        reachable_orientations = []
        reachable_joint_configs = []
        
        # 创建临时全关节配置（其他关节设为默认值）
        default_joint_config = self.default_dof_pos.cpu().numpy()
        
        for joint_config in joint_configs:
            # 构建完整的关节配置
            full_config = default_joint_config.copy()
            full_config[joint_indices] = joint_config
            
            # 计算正向运动学
            q = full_config.reshape(-1)
            pin.forwardKinematics(self.pinocchio_model, self.pinocchio_data, q)
            pin.updateFramePlacements(self.pinocchio_model, self.pinocchio_data)
            
            # 获取该手指的位置和姿态
            tip_frame_idx = self.pinocchio_tips_idx[finger_idx]
            tip_pos = self.pinocchio_data.oMf[tip_frame_idx].translation.copy()
            tip_rot = self.pinocchio_data.oMf[tip_frame_idx].rotation.copy()
            
            # 转换为四元数
            R_tensor = torch.from_numpy(tip_rot).unsqueeze(0).to(self.device, dtype=torch.float32)
            tip_quat = mat3x3_to_xyzw(R_tensor).squeeze(0).cpu().numpy()
            
            # 检查是否碰撞（可选，如果计算量大可以跳过）
            # 这里简化处理，假设都可达
            
            reachable_positions.append(tip_pos)
            reachable_orientations.append(tip_quat)
            reachable_joint_configs.append(joint_config)
        
        # 转换为 tensor 并存储
        self.reachable_workspace[finger_idx] = {
            'positions': torch.from_numpy(np.array(reachable_positions)).to(self.device, dtype=torch.float32),
            'orientations': torch.from_numpy(np.array(reachable_orientations)).to(self.device, dtype=torch.float32),
            'joint_configs': torch.from_numpy(np.array(reachable_joint_configs)).to(self.device, dtype=torch.float32),
        }
        
        print(f"手指 {finger_idx+1}: 找到 {len(reachable_positions)} 个可达位置")
    
    print("可达工作空间预计算完成！")

def _get_finger_joint_indices(self):
    """
    获取每个手指对应的关节索引
    
    返回：
        finger_joint_indices: list of lists, 每个元素是一个手指的关节索引列表
    """
    # 根据 dof_names 推断每个手指的关节
    # 假设命名规则是 finger1_joint1, finger1_joint2, ...
    finger_joint_indices = []
    
    for finger_num in range(1, 6):  # finger1 到 finger5
        finger_joints = []
        for i, name in enumerate(self.dof_names):
            if f'finger{finger_num}' in name.lower() or f'finger{finger_num}_' in name.lower():
                finger_joints.append(i)
        finger_joint_indices.append(finger_joints)
    
    return finger_joint_indices
```

### 3. 修改采样函数

```python
def _resample_ee_goal_cart_once(self, env_ids, max_retries=50, min_finger_distance=0.02):
    """
    从预计算的可达工作空间中采样目标位置
    
    Args:
        env_ids: 需要采样的环境ID列表
        max_retries: 最大重试次数（用于碰撞检测）
        min_finger_distance: 手指之间的最小安全距离
    """
    if len(env_ids) == 0:
        return
    
    if not isinstance(env_ids, torch.Tensor):
        env_ids = torch.tensor(env_ids, device=self.device, dtype=torch.long)
    else:
        env_ids = env_ids.to(self.device)
    
    # 如果启用了预计算，从可达位置中采样
    if self.cfg.goal_ee.precompute_reachable_workspace and hasattr(self, 'reachable_workspace'):
        for finger_idx in range(len(self.finger_tips_idx)):
            # 从该手指的可达位置中随机选择
            num_reachable = self.reachable_workspace[finger_idx]['positions'].shape[0]
            random_indices = torch.randint(0, num_reachable, (len(env_ids),), device=self.device)
            
            # 设置位置和姿态
            self.finger_tip_goal_cart[env_ids, finger_idx] = \
                self.reachable_workspace[finger_idx]['positions'][random_indices]
            self.finger_tip_goal_orn[env_ids, finger_idx] = \
                self.reachable_workspace[finger_idx]['orientations'][random_indices]
        
        # 检查碰撞
        collision_mask = self._check_finger_self_collision(env_ids, min_distance=min_finger_distance)
        colliding_env_ids = env_ids[~collision_mask]
        
        # 如果有碰撞，重新采样（最多重试 max_retries 次）
        if len(colliding_env_ids) > 0:
            for retry in range(max_retries):
                if len(colliding_env_ids) == 0:
                    break
                
                # 重新采样碰撞的手指
                for finger_idx in range(len(self.finger_tips_idx)):
                    num_reachable = self.reachable_workspace[finger_idx]['positions'].shape[0]
                    random_indices = torch.randint(0, num_reachable, (len(colliding_env_ids),), device=self.device)
                    
                    self.finger_tip_goal_cart[colliding_env_ids, finger_idx] = \
                        self.reachable_workspace[finger_idx]['positions'][random_indices]
                    self.finger_tip_goal_orn[colliding_env_ids, finger_idx] = \
                        self.reachable_workspace[finger_idx]['orientations'][random_indices]
                
                # 再次检查碰撞
                collision_mask = self._check_finger_self_collision(colliding_env_ids, min_distance=min_finger_distance)
                colliding_env_ids = colliding_env_ids[~collision_mask]
            
            if len(colliding_env_ids) > 0:
                print(f"Warning: {len(colliding_env_ids)} environments still have collisions after {max_retries} retries")
    else:
        # 使用原来的方法（随机采样关节角度）
        # ... existing code ...
        pass
```

### 4. 在初始化时调用

在 `__init__` 或 `_init_buffers` 中添加：
```python
if self.cfg.goal_ee.precompute_reachable_workspace:
    self._precompute_reachable_workspace()
```

## 优化建议

1. **减少采样密度**：如果内存不足，可以降低 `workspace_sampling_density`
2. **按手指分别处理**：每个手指独立采样，避免组合爆炸
3. **缓存到文件**：预计算结果可以保存到文件，避免每次初始化都计算
4. **碰撞检测优化**：可以在预计算时就过滤掉碰撞的配置



