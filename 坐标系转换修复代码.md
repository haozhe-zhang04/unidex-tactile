# 坐标系转换修复代码

## 核心问题总结

1. **`commands` 中 F_cmd 的坐标系不一致**：有时是 finger_tip local，有时是 base
2. **`_reward_ee_force_x/y/z` 函数**：形状错误 + 坐标系错误
3. **reshape 操作**：需要验证顺序一致性

## 修复代码

### 1. 添加辅助函数（在类中添加）

```python
def transform_force_finger_tip_local_to_base(self, forces_local):
    """
    将 finger_tip local 坐标系的力转换到 base 坐标系
    
    Args:
        forces_local: (num_envs, num_fingers, 3) - finger_tip local 坐标系
    
    Returns:
        forces_base: (num_envs, num_fingers, 3) - base 坐标系
    """
    num_fingers = forces_local.shape[1]
    finger_tip_quat = self.rigid_state[:, self.finger_tips_idx, 3:7]
    base_quat_expanded = self.base_quat.unsqueeze(1).expand(self.num_envs, num_fingers, 4)
    
    # finger_tip local -> world
    forces_world = quat_apply(
        finger_tip_quat.reshape(-1, 4),
        forces_local.reshape(-1, 3)
    ).reshape(self.num_envs, num_fingers, 3)
    
    # world -> base
    forces_base = quat_rotate_inverse(
        base_quat_expanded.reshape(-1, 4),
        forces_world.reshape(-1, 3)
    ).reshape(self.num_envs, num_fingers, 3)
    
    return forces_base

def transform_force_base_to_world(self, forces_base):
    """
    将 base 坐标系的力转换到 world 坐标系（用于可视化）
    
    Args:
        forces_base: (num_envs, num_fingers, 3) - base 坐标系
    
    Returns:
        forces_world: (num_envs, num_fingers, 3) - world 坐标系
    """
    num_fingers = forces_base.shape[1]
    base_quat_expanded = self.base_quat.unsqueeze(1).expand(self.num_envs, num_fingers, 4)
    
    forces_world = quat_apply(
        base_quat_expanded.reshape(-1, 4),
        forces_base.reshape(-1, 3)
    ).reshape(self.num_envs, num_fingers, 3)
    
    return forces_world
```

### 2. 修复 `_push_finger_tip` 函数（1466-1468行）

**原代码：**
```python
self.commands[env_ids_apply_push_step1,:, INDEX_TIP_FORCE_X] = self.current_Fxyz_finger_tips_cmd[env_ids_apply_push_step1, :, 0]
self.commands[env_ids_apply_push_step1,:, INDEX_TIP_FORCE_Y] = self.current_Fxyz_finger_tips_cmd[env_ids_apply_push_step1, :, 1]
self.commands[env_ids_apply_push_step1,:, INDEX_TIP_FORCE_Z] = self.current_Fxyz_finger_tips_cmd[env_ids_apply_push_step1, :, 2]
```

**修复后：**
```python
# 转换到 base 坐标系后再赋值
F_cmd_base = self.transform_force_finger_tip_local_to_base(
    self.current_Fxyz_finger_tips_cmd[env_ids_apply_push_step1]
)
self.commands[env_ids_apply_push_step1, :, INDEX_TIP_FORCE_X] = F_cmd_base[:, :, 0]
self.commands[env_ids_apply_push_step1, :, INDEX_TIP_FORCE_Y] = F_cmd_base[:, :, 1]
self.commands[env_ids_apply_push_step1, :, INDEX_TIP_FORCE_Z] = F_cmd_base[:, :, 2]
```

**同样修复 1477-1479行：**
```python
F_cmd_base = self.transform_force_finger_tip_local_to_base(
    self.current_Fxyz_finger_tips_cmd[env_ids_apply_push_step2]
)
self.commands[env_ids_apply_push_step2, :, INDEX_TIP_FORCE_X] = F_cmd_base[:, :, 0]
self.commands[env_ids_apply_push_step2, :, INDEX_TIP_FORCE_Y] = F_cmd_base[:, :, 1]
self.commands[env_ids_apply_push_step2, :, INDEX_TIP_FORCE_Z] = F_cmd_base[:, :, 2]
```

### 3. 修复 `compute_observations` 函数（566-570行）

**原代码：**
```python
F_cmd_local = self.commands[:,:,INDEX_TIP_FORCE_X:(INDEX_TIP_FORCE_Z+1)]
F_cmd_world = quat_apply(self.rigid_state[:,self.finger_tips_idx,3:7].clone(),F_cmd_local)
F_cmd_base = quat_rotate_inverse(base_quat_reshaped,F_cmd_world.reshape(-1,3)).reshape(self.num_envs,num_fingers,3)
commands = self.commands.clone()
commands[:,:,INDEX_TIP_FORCE_X:(INDEX_TIP_FORCE_Z+1)] = F_cmd_base
```

**修复后：**
```python
# commands 中的 F_cmd 已经是 base 坐标系，直接使用
F_cmd_base = self.commands[:,:,INDEX_TIP_FORCE_X:(INDEX_TIP_FORCE_Z+1)]  # (num_envs, num_fingers, 3)
commands = self.commands.clone()
# 不需要再转换
```

### 4. 修复 `_draw_ee_force` 函数（850-851行）

**原代码：**
```python
F_cmd = self.commands[:,:,INDEX_TIP_FORCE_X:INDEX_TIP_FORCE_Z+1].clone()
F_cmd_gloal = quat_apply(self.rigid_state[:,self.finger_tips_idx,3:7].clone(),F_cmd)
```

**修复后：**
```python
F_cmd_base = self.commands[:,:,INDEX_TIP_FORCE_X:INDEX_TIP_FORCE_Z+1].clone()  # base 坐标系
F_cmd_gloal = self.transform_force_base_to_world(F_cmd_base)  # 转换到 world 用于可视化
```

### 5. 修复 `_reward_ee_force_x/y/z` 函数（2406-2439行）

**原代码：**
```python
def _reward_ee_force_x(self):
    xy_forces_local = self.forces[:, self.finger_tips_idx, 0:3]
    force_magn_meas = (xy_forces_local[:, 0]).view(self.num_envs, 1)
    force_magn_cmd = (self.commands[:, INDEX_TIP_FORCE_X]).view(self.num_envs, 1)
    force_magn_error = torch.abs(force_magn_meas - force_magn_cmd).view(self.num_envs)
    force_magn_coeff = self.cfg.rewards.sigma_force
    return torch.exp(-force_magn_coeff*force_magn_error)
```

**修复后：**
```python
def _reward_ee_force_x(self):
    # 获取传感器力（finger_tip local）
    sensor_forces_local = self.sensors_forces[:, :, :3]  # (num_envs, num_fingers, 3)
    
    # 转换到 base 坐标系
    sensor_forces_base = self.transform_force_finger_tip_local_to_base(sensor_forces_local)
    
    # 从 commands 获取 F_cmd（已经是 base 坐标系）
    F_cmd_base = self.commands[:, :, INDEX_TIP_FORCE_X:(INDEX_TIP_FORCE_Z+1)]  # (num_envs, num_fingers, 3)
    
    # 计算误差（都在 base 坐标系）
    force_magn_meas = sensor_forces_base[:, :, 0]  # (num_envs, num_fingers)
    force_magn_cmd = F_cmd_base[:, :, 0]  # (num_envs, num_fingers)
    force_magn_error = torch.abs(force_magn_meas - force_magn_cmd).mean(dim=1)  # (num_envs,) - 对所有手指取平均
    
    force_magn_coeff = self.cfg.rewards.sigma_force
    return torch.exp(-force_magn_coeff * force_magn_error)

def _reward_ee_force_y(self):
    sensor_forces_local = self.sensors_forces[:, :, :3]
    sensor_forces_base = self.transform_force_finger_tip_local_to_base(sensor_forces_local)
    F_cmd_base = self.commands[:, :, INDEX_TIP_FORCE_X:(INDEX_TIP_FORCE_Z+1)]
    
    force_magn_meas = sensor_forces_base[:, :, 1]
    force_magn_cmd = F_cmd_base[:, :, 1]
    force_magn_error = torch.abs(force_magn_meas - force_magn_cmd).mean(dim=1)
    
    force_magn_coeff = self.cfg.rewards.sigma_force
    return torch.exp(-force_magn_coeff * force_magn_error)

def _reward_ee_force_z(self):
    sensor_forces_local = self.sensors_forces[:, :, :3]
    sensor_forces_base = self.transform_force_finger_tip_local_to_base(sensor_forces_local)
    F_cmd_base = self.commands[:, :, INDEX_TIP_FORCE_X:(INDEX_TIP_FORCE_Z+1)]
    
    force_magn_meas = sensor_forces_base[:, :, 2]
    force_magn_cmd = F_cmd_base[:, :, 2]
    force_magn_error = torch.abs(force_magn_meas - force_magn_cmd).mean(dim=1)
    
    force_magn_coeff = self.cfg.rewards.sigma_force
    return torch.exp(-force_magn_coeff * force_magn_error)
```

### 6. 验证 reshape 操作的一致性

在 `compute_observations` 函数中，所有 reshape 操作应该遵循相同的顺序：

```python
# 正确的 reshape 顺序：
# (num_envs, num_fingers, ...) -> (num_envs*num_fingers, ...)
# 顺序：env0_finger0, env0_finger1, ..., env0_finger4, env1_finger0, ...

# 示例验证代码（可以添加到测试中）：
def test_reshape_consistency(self):
    num_envs = 2
    num_fingers = 5
    
    # 创建测试数据
    base_quat = torch.randn(num_envs, 4)
    base_quat_expanded = base_quat.unsqueeze(1).expand(num_envs, num_fingers, 4)
    base_quat_reshaped = base_quat_expanded.reshape(num_envs * num_fingers, 4)
    
    # 验证顺序
    assert torch.allclose(base_quat_reshaped[0], base_quat_expanded[0, 0])  # env0_finger0
    assert torch.allclose(base_quat_reshaped[4], base_quat_expanded[0, 4])  # env0_finger4
    assert torch.allclose(base_quat_reshaped[5], base_quat_expanded[1, 0])  # env1_finger0
```

## 总结

修复后的坐标系约定：
- **`commands` 中的 F_cmd**：始终是 **base 坐标系**
- **`current_Fxyz_finger_tips_cmd`**：**finger_tip local 坐标系**
- **`sensors_forces`**：**finger_tip local 坐标系**
- **所有 reward 和 observation**：统一转换到 **base 坐标系**

这样可以确保：
1. 坐标系一致性
2. 代码可维护性
3. 避免重复的转换代码



